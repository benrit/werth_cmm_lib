from dataclasses import dataclass
import os
import datetime as dt
import numpy as np
from enum import Enum
import re
import json


def import_points(filename: str) -> list[object]:
    json_file = open(filename, "r")
    j = json.load(json_file)
    json_file.close()
    return j


probes = {
    "Master" : {"name": "MProbe4_0", "diameter": 8.0},
    "Probe0.7" : {"name": "MProbe4_9", "diameter": 0.7},
    "Probe1.5" : {"name": "MProbe4_10", "diameter": 1.5},
    "VIDEOIP_0": {"name": "VIDEOIP_0", "diameter": 0.0}
}


class Werth:
    _elements = None
    _tempco = 0.00001150
    _w3d_deflection = 0.05
    _writer = None
    _saftey_plane = None
    _macro = None
    _name = None
    _start_gui = None
    _current_probe = None

    def __init__(self, writer, name, macro=False, show_start_gui=False):
        self._elements = []
        self._writer = writer
        self._macro = macro
        self._name = name
        self._start_gui = show_start_gui
        
    def add(self, element):
        if isinstance(element, Probe):
            self._current_probe = element

        self._elements.append(element)

    def set_safty_plane(self, saftey_plane):
        self._saftey_plane = saftey_plane

    def unroll(self, element, obj):
          for item in element:
            if type(item) == obj:
                self._writer(item.definition())
            if type(item) == Pattern:
                self.unroll(item._elements, obj)



    def generate(self):
        self._writer(header(self._macro))
        self._writer(algo_definitions())
        
        self.unroll(self._elements, Call)
        if self._macro:
            self._writer(f"\n\nMACRO / {self._name}\n")  
        
        self._writer(f"\n")  
        self._writer(f"FILNAM / '{self._name}'\n\n")
        self._writer(f"TECOMP / ON, {self._tempco:.8f}\n")
        self._writer(f"W3D / DEFLECTION, {self._w3d_deflection:.8f}\n\n")

        if self._start_gui:
            self._writer(f"SYSTEM / EXECUTE, 'pythonw.exe C:\\Werth\\user\\Scripts\\WerthStartGui\\WerthStartGui.py -f {self._name} -pd $SYSDMISAUTONAME', 1\n\n")

        self.unroll(self._elements, Probe)


        for item in self._elements:

            self._writer(str(item))

        # self._writer(f"SYSTEM / EXECUTE, 'python.exe C:\\Werth\\user\\Scripts\\WerthConverter\\WerthConverter.py -f {self._name}', 1\n\n")

        if self._macro:
            self._writer("ENDMAC\n")
        self._writer("ENDFIL\n")

        
class Probe:
    _name = ""
    _diameter = 0.0
    _search = None
    _approach = None
    _algo = ""
    _scan_speed = None
    _deflection = 0.065
    _werth = None

    def __init__(self, w: Werth, probe, approach=2.0, search=2.0, scan_speed=1.5):
        self._name = probe['name']
        self._diameter = probe['diameter']
        self._approach = approach
        self._search = search
        self._scan_speed = scan_speed
        self._werth = w
        w.add(self)

    def definition(self):
        return f"S({self._name}) = SNSDEF / PROBE, FIXED, CART, 0.00000000, 0.00000000, 0.00000000, 0.00000000, 0.00000000, 0.00000000, 0.00000000,0.00000000, 0.00000000\n"
   

    def set_deflection(self, value):
        if value < 0.0 or value > 1.0:
            return
        
        self._deflection = value

    def set_approach(self, value):
        Property(self._werth, self, "_approach", value)
        
    def __setitem__(self, key, value):
        setattr(self, key, value)

    def __str__(self) -> str:
        return ""


class Property:
    _element = None
    _property = None
    _value = None

    def __init__(self, w: Werth, element, property, value):
        self._element = element
        self._property = property
        self._value = value

        w.add(self)

    def __str__(self) -> str:
        self._element[self._property] = self._value

        return ""


def header(marco: bool):

    now = dt.datetime.now()

    return f"""
$$ DMIS file generated by Python
BEGIN / CHFILE
	TYPE = {"MAIN" if not marco else "MACRO"}
	VERSION = L-9.44.00.0064.00.08 C:\Werth\Werth\Winwerth
	DATE = {now.strftime("%d.%m.%y")}
	TIME = {now.strftime("%H:%M:%S")}
	MAJORVERSION = 9
	MINORVERSION = 440000640008
	MC-VERSION = MoSeS V8.44.00.0009.00.01
	USER = Guest
	TEACHEDIT = YES
	SENSORCHECK = Yes
END / CHFILE\n\n"""


def units(length="MM", angle="ANGDEC"):
    return f"UNITS / {length}, {angle}\n"
 

def algo_definitions():
    return """$$ algorithm definitions
VA(PROBE) = ALGDEF / CODE, 1600
VA(PROBEC) = ALGDEF / CODE, 1601
VA(SCAN_NOMGEO_6503) = ALGDEF / CODE, 6503
VA(SCAN_SPEED) = ALGDEF / CODE, 6130
VA(SCAN_DEV_EXT) = ALGDEF / CODE, 6140
VA(SCAN_NOMGEO_6500) = ALGDEF / CODE, 6500
"""


def chr_element(name:str, element:str):
    temp = f"T({name}) = TOL / DIAM, 0.20000000, -0.20000000\n"
    temp += f"OUTPUT / F({element}), T({name})\n"
    return temp


def check_saftey_plane(w: Werth, sp):

    if sp == None:
        return w._saftey_plane
    elif sp == False:
        return False
    else:
        return sp


class Pattern:
    _name = None
    _pattern = None
    _werth = None
    _elements = None
    _angles = None
    _count = None
    _loop_var = None
    _saftey_plane = None
    
    _current_probe = None


    def __init__(self, w: Werth, name: str, loop_var: str = "L1", saftey_plane = None) -> None:
        self._name = name
        self._pattern = []
        self._werth = w        
        self._elements = []
        self._loop_var = loop_var
        self._saftey_plane = saftey_plane if saftey_plane else w._saftey_plane
        self._current_probe = w._current_probe
        
        w.add(self)


    def linear(self, x: float, y: float, z: float, i: float, j: float, k: float, count: int, offset: float):

        p = np.array([x, y, z])
        v = np.array([i, j, k])
        
        self._pattern.extend([p + (v * (offset * i)) for i in range(count)])

    def rectengular(self, x=0.0, y=0.0, z=0.0, offsetx=0.0, countx = 0, offsety=0.0, county=0, count=None):

        self._count = count
        
        for _y in range(county):
            y_off = (offsety * _y) + y
            self.linear(x=x, y=y_off, z=z, i=1.0, j=0.0, k=0.0, count=countx, offset=offsetx)


    def set_angles(self, angles: list):
        if angles:
            self._angles = angles
        

    def add(self, element):
        if isinstance(element, Probe):
            self._current_probe = element

        self._elements.append(element)


    def __str__(self) -> str:
        loop_count = len(self._pattern)
        
        if self._count == None:
            self._count = len(self._pattern)

        temp = "DMIS / REPEATSTART\n"
        temp += f"BEGIN / LOOPDEF, VARIABLE, (LOOP_{self._name}), {loop_count}, 0\n"
        temp += f"DECL / LOCAL, REAL, {self._loop_var}Offset[{loop_count};3]\n"
        if self._angles:
            temp += f"DECL / LOCAL, REAL, {self._loop_var}Angle[{len(self._angles)}]\n" # Angle

        temp += f"DECL / GLOBAL, INT, {self._loop_var}\n\n"
        offsets = ",".join([f"{{{i[0]}, {i[1]}, {i[2]}}}" for i in self._pattern])
        temp += f"LET / ${self._loop_var}Offset = {{{offsets}}}\n"
        temp += "DECL / LOCAL, REAL, xoffset, yoffset, zoffset\n"

        if self._angles:
            angles = ",".join([f"{i:.5f}" for i in self._angles])
            temp += f"LET / ${self._loop_var}Angle = {{{angles}}}\n"

        temp += "END / LOOPDEF\n"

        temp += f"SAVE / D(LOOPCOOR_{self._name}), 3\n"
        temp += f"FOR / ${self._loop_var} = 1, TO, {self._count}\n"
        temp += "W3D / CLEAR\n"
        temp += "W2D / CLEAR\n"
        temp += "CAD / CLEAR\n"
        temp += f"LET / $xoffset = ${self._loop_var}Offset[${self._loop_var};1]\n"
        temp += f"LET / $yoffset = ${self._loop_var}Offset[${self._loop_var};2]\n"
        temp += f"LET / $zoffset = ${self._loop_var}Offset[${self._loop_var};3]\n"

        temp += f"SAVE / D(LOOPDAT_{self._name}), 3\n"
        temp += f"FC(LOOPELM_{self._name}) = FEAT / POINT, CART, $xoffset, $yoffset, $zoffset, 0.0, 0.0, 0.0\n"

        temp += "WKPLAN / NONE\n"
        temp += f"D(LOOPDPT_{self._name}) = TRANS / XORIG, FA(LOOPELM_{self._name}), YORIG, FA(LOOPELM_{self._name}), ZORIG, FA(LOOPELM_{self._name})\n"
        
        if self._angles:
            temp += f"FC(LOOPANG_{self._name}) = FEAT / LINE, UNBND, CART, 0.0, 0.0, 0.0, COS(RAD(${self._loop_var}Angle[${self._loop_var}])), SIN(RAD(${self._loop_var}Angle[${self._loop_var}])), 0.00000000, 0.00000000, 0.00000000,1.00000000\n"
            temp += "WKPLAN / NONE\n"
            temp += f"D(LOOPDAX_{self._name}) =  ROTATE / ZAXIS, FA(LOOPANG_{self._name}), XDIR\n"
        
        
        temp += f"TEXT / OUTPUT , 'OFFSET x:$xoffset, y:$yoffset, z:$zoffset'\n"     

        for item in self._elements:
            
            temp += str(item)

        temp += "DMIS / REPEATEND\n"
        temp += f"RECALL / D(LOOPDAT_{self._name})\n"

        temp += f"NEXT / ${self._loop_var}\n"
        temp += f"RECALL / D(LOOPCOOR_{self._name})\n\n"

        return temp


class Circle_Type(Enum):
    INNER = "INNER"
    OUTER = "OUTER"


class Element:
    _id = None
    _parent = None
    _saftey_plane = None
    _probe = None

    def __init__(self, parent: Werth | Pattern, name: str, saftey_plane=None, probe: Probe = None) -> None:

        self._parent = parent
        if probe:
            self._probe = probe
        else:
            self._probe = parent._current_probe

            
        if isinstance(parent, Werth):
            self._id = name
        elif isinstance(parent, Pattern):
            self._id = name + f"_${parent._loop_var}"

        if saftey_plane == None:
            self._saftey_plane = parent._saftey_plane
        elif saftey_plane == False:
            self._saftey_plane = False
        else:
            self._saftey_plane = saftey_plane


        parent.add(self)


    def get_saftey_plane(self):
        if self._saftey_plane:
            return f"CZSLCT / CZ({self._saftey_plane._id}), ON, FIX\n"


class Pos(np.ndarray):
    def __new__(cls, *args, **kwargs):
        
        return super().__new__(cls, *((3,),), float)
    
    def __init__(self, x=0.0, y=0.0, z=0.0) -> None:
        self[0] = x
        self[1] = y
        self[2] = z
        super().__init__()

    def x(self):
        return self[0]
    

class Vec(np.ndarray):
    def __new__(cls, *args, **kwargs):
        
        return super().__new__(cls, *((3,),), float)
    
    def __init__(self, i=0.0, j=0.0, k=0.0) -> None:
        self[0] = i
        self[1] = j
        self[2] = k
        super().__init__()


class T_Point:
    _id = ""
    _x=0.0
    _y=0.0
    _z=0.0


    def __init__(self, w:Werth, name, pos: Pos=Pos(0.0, 0.0, 0.0), relativeTo=None):

        self._id = name
        
        if relativeTo:
            self._x = relativeTo._x + pos[0]
            self._y = relativeTo._y + pos[1]
            self._z = relativeTo._z + pos[2]
        else:
            self._x = pos[0]
            self._y = pos[1]
            self._z = pos[2]

        w.add(self)

        
    def __str__(self) -> str:
            return f"FA({self._id}) = FEAT / POINT, CART, {self._x:.8f}, {self._y:.8f}, {self._z:.8f}, 0.0, 0.0, 0.0\n\n"
        
    

class Plane:
    _id=""
    _x=0.0
    _y=0.0
    _z=0.0
    _theoretical=False
    _points = None
    _position = None
    _vector = None

    def __init__(self, w:Werth, name, x=0.0, y=0.0, z=0.0, i=0.0, j=0.0, k=0.0, theoretical = False):
        self._id = name
        self._x = x
        self._y = y
        self._z = z
        self._theoretical = theoretical
        self._points = []
        self._position = np.array([x, y, z])
        self._vector = np.array([i, j, k])
    
        w.add(self)

    def add_point(self, x=0.0, y=0.0, z=0.0, dx=None, dy=None, dz=None):
        x = x if not dx else self._x + dx
        y = y if not dx else self._y + dy
        z = z if not dx else self._z + dz
        print(f"[PLANE] {self._id} x: {x}\ty: {y}\tz: {z}")
        self._points.append({"x": x, "y": y, "z": z})
        


    def __str__(self):
        if self._theoretical:
            return f"FA({self._id}) = FEAT / PLANE, CART, {self._x:.8f}, {self._y:.8f}, {self._z:.8f}, 0.00000000, 0.00000000, 1.00000000\n\n"
        else:
            return ""


class Goto:
    _x = 0.0
    _y = 0.0
    _z = 0.0
    _probe = None
    def __init__(self, w: Werth, x=0.0, y=0.0, z=0.0, relativeTo: T_Point=None, probe: Probe=None):

        self._probe = probe

        if relativeTo:
            self._x = relativeTo._x + x
            self._y = relativeTo._y + y
            self._z = relativeTo._z + z
        else:
            self._x = x
            self._y = y
            self._z = z


        w.add(self)


    def __str__(self):
        temp = f"SNSLCT / S({self._probe._name})\n"
        temp += f"GOTO / {self._x:.8f}, {self._y:.8f}, {self._z:.8f}\n\n"
        return temp


class Translate:
    _parent = None
    _x = None
    _y = None
    _z = None

    def __init__(self, parent):
        self._parent = parent

    def __str__(self) -> str:
        t=[]
        temp = "WKPLAN / NONE \n"
        temp += f"D({self._parent._id}) = TRANS / "
        if self._x: t.append(f"XORIG, FA({self._x._id})")
        if self._y: t.append(f"YORIG, FA({self._y._id})")
        if self._z: t.append(f"ZORIG, FA({self._z._id})")
        temp += ", ".join(t)
        temp += "\n\n"

        return temp

    def X(self, element):
        self._x = element
        return self

    def Y(self, element):
        self._y = element
        return self

    def Z(self, element):
        self._z = element
        return self


class Rotate:
    _parent = None
    _dir = None
    _axis = "XAXIS"
    _element = None

    def __init__(self, parent):
        self._parent = parent

    def __str__(self) -> str:
        temp = "WKPLAN / NONE \n"
        temp += f"D({self._parent._id}) = ROTATE / "
        temp += f"{self._axis}, FA({self._element._id}), {self._dir}"
        temp += "\n\n"

        return temp

    def XDIR(self, element):
        self._dir = "XDIR"
        self._element = element
        return self

    def YDIR(self, element):
        self._dir = "YDIR"
        self._element = element
        return self

    def ZDIR(self, element):
        self._dir = "ZDIR"
        self._element = element
        return self

    def ZAXIS(self):
        self._axis = "ZAXIS"
        return self
    

class Alignment:
    _id = None
    _w: Werth = None
    _item = None
    _output = None

    def __init__(self, w: Werth | Pattern, name: str):

        if isinstance(w, Werth):
            self._id = name
        elif isinstance(w, Pattern):
            self._id = name + f"_${w._loop_var}"


        self._output = ""

        w.add(self)
        
    def translate(self) -> Translate:
        self._item = Translate(self)
        return self._item
    
    def rotate(self) -> Rotate:
        self._item = Rotate(self)
        return self._item
    
    def save(self):
        self._output += f"SAVE / D({self._id}), 3\n\n"
        return self

    def recall(self):
        self._output += f"RECALL / D({self._id})\n\n"
        return self

    def __str__(self) -> str:
        temp = ""
        if self._item:
            temp += str(self._item)
        
        if self._output:
            temp += self._output


        return temp
    

class M_Point(Element):
    
    _position=None
    _vector=None
    _output=None

    def __init__(self, w: Werth, name:str, pos: Pos, vec: Vec, probe: Probe = None, saftey_plane=None) -> None:
        super().__init__(w, name, saftey_plane, probe)

        self._position = pos
        self._vector = vec
        self._output = ""


    def spacePointDist(self, nom: float=0.0, utol: float=0.0, ltol: float=0.0):
        pos = self._position
        vec = self._vector
        temp = f"TEXT / OUTPUT , '{self._id}_t,SpacePointDist,{nom},{utol},{ltol},&{self._id}|x,&{self._id}|y,&{self._id}|z,{pos[0]},{pos[1]},{pos[2]},{vec[0]},{vec[1]},{vec[2]}'\n"
        self._output += temp
        return self


    def xValue(self, nom: float=0.0, utol: float=0.0, ltol: float=0.0):
        pos = self._position
        vec = self._vector
        temp = f"TEXT / OUTPUT , '{self._id}_x,xValue,{nom},{utol},{ltol},&{self._id}|x,&{self._id}|y,&{self._id}|z,{pos[0]},{pos[1]},{pos[2]},{vec[0]},{vec[1]},{vec[2]}'\n"
        self._output += temp
        return self


    def yValue(self, nom: float=0.0, utol: float=0.0, ltol: float=0.0):
        pos = self._position
        vec = self._vector
        temp = f"TEXT / OUTPUT , '{self._id}_y,yValue,{nom},{utol},{ltol},&{self._id}|x,&{self._id}|y,&{self._id}|z,{pos[0]},{pos[1]},{pos[2]},{vec[0]},{vec[1]},{vec[2]}'\n"
        self._output += temp
        return self


    def zValue(self, nom: float=0.0, utol: float=0.0, ltol: float=0.0):
        pos = self._position
        vec = self._vector
        temp = f"TEXT / OUTPUT , '{self._id}_z,zValue,{nom},{utol},{ltol},&{self._id}|x,&{self._id}|y,&{self._id}|z,{pos[0]},{pos[1]},{pos[2]},{vec[0]},{vec[1]},{vec[2]}'\n"
        self._output += temp
        return self


    def __str__(self) -> str:
        temp = f"F({self._id}) = FEAT / POINT, CART, {self._position[0]}, {self._position[1]}, {self._position[2]}, 0.00000000, 0.00000000, 0.00000000\n"
        temp += "MODE / PROG\n"
        temp += f"POINTDIST / PARAMS, FA({self._id})\n"
        temp += "PIEZOWFP / OFF\n"
        temp += f"MEAS / POINT, F({self._id}), 1\n"
        temp += "SNSET / VA(SCAN_NOMGEO_6500)\n"
        temp += f"SNSLCT / S({self._probe._name})\n"
        temp += f"SNSET / SEARCH, {self._probe._search}\n"
        temp += f"SNSET / APPRCH, {self._probe._approach}\n"
        if self._saftey_plane:
            temp += f"CZSLCT / CZ({self._saftey_plane._id}), ON, FIX\n"
        temp += f"PTMEAS / CART, {self._position[0]}, {self._position[1]}, {self._position[2]}, {self._vector[0]*-1.0}, {self._vector[1]*-1.0}, {self._vector[2]*-1.0}\n"
        temp += "ENDMES\n"
        if self._output:
            temp += self._output
        temp += "\n"
        return temp


class M_Line(Element):
    _id = None
    _len = None
    _angle = None
    
    _points = None   
    _position = None
    _vector = None


    def __init__(self, w: Werth | Pattern, name: str, x: float, y: float, z: float, i: float, j: float, k: float, len: float, angle: float, probe: Probe = None, saftey_plane=None) -> None:
        super().__init__(w, name, saftey_plane, probe)
        self._angle = angle
        self._points = []

        self._position = np.array([x, y, z])
        self._vector = np.array([i, j, k])
        self._len = len


    def add_point(self, x: float=0.0, y: float=0.0, z: float=0.0, probe=None, move_to_saftey_plane=None):
        probe = probe if probe else self._probe
        move_to_saftey_plane = move_to_saftey_plane if move_to_saftey_plane else self._saftey_plane

        v = np.array([0.0, 0.0, 1.0])
        k = self._vector #np.array([self._i, self._j, self._k])
        p = np.radians(self._angle)
        vrot = v*np.cos(p) + (np.cross(k, v)*np.sin(p)) + k*(np.dot(k, v))*(1-p)
        point = (k * x) + self._position

        self._points.append({"type": "single", "x": point[0], "y": point[1], "z": point[2], "i": vrot[0], "j": vrot[1], "k": vrot[2], "probe": probe, "MTSP": move_to_saftey_plane})

    def add_points(self, count = 4, probe=None, move_to_saftey_plane=None):
        
        pos_step = self._len / (count - 1)
        pos = 0
        for i in range(count):
            self.add_point(pos, 0.0, 0.0, probe=probe, move_to_saftey_plane=move_to_saftey_plane)
            pos += pos_step
            

    def __str__(self) -> str:
        p = self._position
        v = self._vector
        temp = f"F({self._id}) = FEAT / LINE, UNBND,CART, {p[0]:.8f}, {p[1]:.8f}, {p[2]:.8f}, {v[0]:.8f}, {v[1]:.8f}, {v[2]:.8f}\n"
        temp += "MODE / PROG\n"
        temp += f"POINTDIST / PARAMS, FA({self._id})\n"
        temp += "PIEZOWFP / OFF\n"
        temp += f"MEAS / LINE, F({self._id}), {len(self._points)}\n"
        
        pre_point = None
        for index, point in enumerate(self._points):
            position = np.array([point['x'], point['y'], point['z']])
            vector = np.array([point['i'], point['j'], point['k']]) * -1
            approach = position + (vector * self._probe._approach ) + (vector * (self._probe._diameter / 2))

            temp += "SNSET / VA(SCAN_NOMGEO_6500)\n"
            temp += f"SNSLCT / S({self._probe._name})\n"
            temp += f"SNSET / SEARCH, {self._probe._search:.8f}\n"
            temp += f"SNSET / APPRCH, {self._probe._approach:.8f}\n"
            if (sp:=self.get_saftey_plane()) and index == 0:
                temp += sp

            else:
                temp += f"GOTO / {pre_point[0]:.8f}, {pre_point[1]:.8f}, {pre_point[2]:.8f}\n"
                temp += f"GOTO / {approach[0]:.8f}, {approach[1]:.8f}, {approach[2]:.8f}\n"
            temp += f"PTMEAS / CART, {point['x']:.8f}, {point['y']:.8f}, {point['z']:.8f}, {point['i']:.8f}, {point['j']:.8f}, {point['k']:.8f}\n"

            pre_point = approach

        temp +="ENDMES\n\n"
        
        return temp


class M_Plane(Element):
    
    _x = None
    _y = None
    _z = None
    _i = None
    _j = None
    _k = None
    _probe = None
    _position = None
    _vector = None

    def __init__(self, w: Werth | Pattern, name: str, 
                 x: float, 
                 y: float, 
                 z: float, 
                 i: float=0.0, 
                 j: float=0.0, 
                 k: float= 1.0, 
                 probe: Probe = None, 
                 saftey_plane = None) -> None:
        
        super().__init__(w, name, saftey_plane, probe)

        self._x = x
        self._y = y
        self._z = z
        self._i = i
        self._j = j
        self._k = k

        self._points = []

        self._position = np.array([x, y, z])
        self._vector = np.array([i, j, k])


    def add_point(self, x: float, y: float, z: float, probe=None, move_to_saftey_plane=False):
        probe = probe if probe else self._probe

        self._points.append({"type": "single", "x": x, "y": y, "z": z, "i": self._i*-1, "j": self._j*-1, "k": self._k*-1, "probe": probe, "MTSP": move_to_saftey_plane})

    def add_support_point(self, x: float, y: float, z: float):
        self._points.append({"type": "support", "x": x, "y": y, "z": z})


    def add_circle_path(self, diameter=0.0, x=0.0, y=0.0, z=0.0, start_angle=0, angle_range=360, count=8, probe=None, move_to_saftey_plane=False):
    
        angle_step = angle_range / count

        angle = start_angle

        circumference = diameter * np.pi
        arc_length = circumference / count
        print(arc_length)

        radius = diameter / 2
        for _ in range(count):
            i = np.cos(np.radians(angle))
            j = np.sin(np.radians(angle))
            k = 1
            cx = (i * radius) + x
            cy = (j * radius) + y
            cz = z
            self._points.append({"type": "single", "x": cx, "y": cy, "z": cz, "i": self._i*-1, "j": self._j*-1, "k": self._k*-1, "probe": probe, "MTSP": move_to_saftey_plane})

            print(f"[ARC POINT] {cx} {cy} {cz}")
            angle += angle_step
            
            
    def __str__(self) -> str:
        
        temp = f"F({self._id}) = FEAT / PLANE, CART, {self._x:.8f}, {self._y:.8f}, {self._z:.8f}, {self._i:.8f}, {self._j:.8f}, {self._k:.8f}\n"
        temp += "MODE / PROG\n"
        temp += f"POINTDIST / PARAMS, FA({self._id})\n"
        temp += "PIEZOWFP / OFF\n"
        temp += f"MEAS / PLANE, F({self._id}), {len(self._points)}\n"
        
        pre_point = None
        for index, point in enumerate(self._points):

            if point['type'] == 'single':
                position = np.array([point['x'], point['y'], point['z']])
                vector = np.array([point['i'], point['j'], point['k']]) * -1
                approach = position + (vector * self._probe._approach ) + (vector * self._probe._diameter)

                temp += "SNSET / VA(SCAN_NOMGEO_6500)\n"
                temp += f"SNSLCT / S({self._probe._name})\n"
                temp += f"SNSET / SEARCH, {self._probe._search:.8f}\n"
                temp += f"SNSET / APPRCH, {self._probe._approach:.8f}\n"
                if (sp:=self.get_saftey_plane()) and index == 0: 
                    temp += sp
                    
                else:
                    # temp += f"GOTO / {pre_point[0]:.8f}, {pre_point[1]:.8f}, {pre_point[2]:.8f}\n"
                    if point['MTSP'] == True:
                        temp += f"CZSLCT / CZ({self._saftey_plane._id}), ON, FIX\n"
                    else:
                        temp += f"GOTO / {approach[0]:.8f}, {approach[1]:.8f}, {approach[2]:.8f}\n"


                temp += f"PTMEAS / CART, {point['x']:.8f}, {point['y']:.8f}, {point['z']:.8f}, {point['i']:.8f}, {point['j']:.8f}, {point['k']:.8f}\n"

            if point['type'] == 'support':
                temp += f"GOTO / {point['x']:.8f}, {point['y']:.8f}, {point['z']:.8f}\n"



        temp +="ENDMES\n\n"
        
        return temp


class M_Circle(Element):
    _diameter = 0.0
    _start_angle = 0
    _angle = 360
    
    _circle_type: Circle_Type = None

    _points = None

    _position = None
    _vector = None

    _output = None

    def __init__ (self, w:Werth | Pattern, name, diameter: float=0.0, x=0.0, y=0.0, z=0.0, circle_type: Circle_Type=None, probe: Probe=None, saftey_plane=None):
        super().__init__(w, name, saftey_plane, probe)

        assert not circle_type == None, "no circle type secified Circle_Type.INNER or Circle_Type.OUTER"

        self._circle_type = circle_type

        self._diameter = diameter

        self._position = np.array([x, y, z])
        self._vector = np.array([0.0, 0.0, 1.0])
        
        self._points = []
        self._output = ""


    def add_points(self, start_angle=0.0, angle_range=360.0, count=8, angles: list=None, probe=None, move_to_saftey_plane=False):
        probe = probe if probe else self._probe
        if angles:
            for a in angles:
                self._points({"type": "single", "angle": a, "probe": probe, "MTSP": move_to_saftey_plane})
        else:
            angle_step = angle_range / count
            angle = start_angle
            for _ in range(count):
                self.add_point(angle=angle, probe=probe, move_to_saftey_plane=move_to_saftey_plane)
                angle += angle_step


    def add_point(self, angle=None, dx=0.0, dy=0.0, probe=None, move_to_saftey_plane=False):
        probe = probe if probe else self._probe
        if angle != None:
            self._points.append({"type": "single", "angle": angle, "dx": dx, "dy": dy, "probe": probe, "MTSP": move_to_saftey_plane})


    def add_scan(self, start_angle=0.0, angle_range=360.0):
        circumstances = self._diameter * np.pi
        ar = angle_range / 360.0

        count = round(circumstances * ar) + 1
        angle_step = (angle_range / count) 

        self._points.append({"type": "scan", "angles": [start_angle + (angle_step * a) for a in range(count + 1)]})
    
        
    def move_to(self):
        pass


    def calc_support_points(self, angle, angle_step, num_point):
        
        a_step = angle_step / num_point
        support_point_start_angle = (angle - angle_step) + a_step
        pl = []
        for _ in range(num_point):
            pl.append({"type": "support", "angle": support_point_start_angle})
            support_point_start_angle += a_step
        return pl
    

    def add_support_points(self):
        pl = []
        if len(self._points) > 0:
            # adding support points
            
            for index, point in enumerate(self._points):
                if point['type'] == "scan":
                    pl.append(point)
                    continue

                if index == 0:
                    angle_step = point['angle']

                if point["type"] == "single":
                    angle = point['angle']
                    angle_step = angle - angle_step
                    
                    if index !=0: pl.append({"type": "support", "angle": angle - angle_step})
                    if not point["MTSP"]: 
                        num_point = round((((self._diameter * 3.1415) / 360) * angle_step) / 3 ) 
                        if num_point > 0:
                            pl.extend(self.calc_support_points(angle, angle_step, num_point + 1))

                pl.append(point)
                angle_step = angle

        return pl


    def calc_point_position(self, angle):
        rad = np.radians(angle)
        i = np.cos(rad)
        j = np.sin(rad)
        p = np.array([i, j, 0]) * (self._diameter / 2)
        v = np.array([i, j, 0]) if self._circle_type.name == "OUTER" else np.array([i, j, 0]) * -1

        return (p, v)
    

    def tolerance(self, Diameter=None, xPos=None, yPos=None):
        if Diameter:
            pass
    
    def diameter(self, nom: float = None, utol: float = 0.0, ltol: float = 0.0):
        pos = self._position
        nom_t = nom if nom else self._diameter

        temp = f"TEXT / OUTPUT , '{self._id}_D,Diameter,{nom_t},{utol},{ltol},&{self._id}|x,&{self._id}|y,&{self._id}|z,&{self._id}|d,&{self._id}|ft,{pos[0]},{pos[1]},{pos[2]},{self._diameter}'\n"
        self._output += temp
        return self

    def roundness(self, nom: float = 0.0, utol: float = 0.0):
        pos = self._position

        temp = f"TEXT / OUTPUT , '{self._id}_Ro,Roundness,{nom},{utol},&{self._id}|x,&{self._id}|y,&{self._id}|z,&{self._id}|d,&{self._id}|ft,{pos[0]},{pos[1]},{pos[2]},{self._diameter}'\n"
        self._output += temp
        return self

    def xValue(self, nom: float = None, utol: float = 0.0, ltol: float = 0.0):
        pos = self._position
        nom_t = nom if nom else pos[0]

        temp = f"TEXT / OUTPUT , '{self._id}_X,X,{nom_t},{utol},{ltol},&{self._id}|x,&{self._id}|y,&{self._id}|z,&{self._id}|d,&{self._id}|ft,{pos[0]},{pos[1]},{pos[2]},{self._diameter}'\n"
        self._output += temp
        return self

    def yValue(self, nom: float = None, utol: float = 0.0, ltol: float = 0.0):
        pos = self._position
        nom_t = nom if nom else pos[1]
        temp = f"TEXT / OUTPUT , '{self._id}_Y,Y,{nom_t},{utol},{ltol},&{self._id}|x,&{self._id}|y,&{self._id}|z,&{self._id}|d,&{self._id}|ft,{pos[0]},{pos[1]},{pos[2]},{self._diameter}'\n"
        self._output += temp
        return self

    def zValue(self, nom: float = None, utol: float = 0.0, ltol: float = 0.0):
        pos = self._position
        nom_t = nom if nom else pos[2]

        temp = f"TEXT / OUTPUT , '{self._id}_Z,Z,{nom_t},{utol},{ltol},&{self._id}|x,&{self._id}|y,&{self._id}|z,&{self._id}|d,&{self._id}|ft,{pos[0]},{pos[1]},{pos[2]},{self._diameter}'\n"
        self._output += temp
        return self


    def __str__(self) -> str:

        radius = self._diameter / 2.0
        circle_x = self._position[0]
        circle_y = self._position[1]
        circle_z = self._position[2]

        temp = f"F({self._id}) = FEAT / CIRCLE, {self._circle_type.value}, CART, {circle_x:.8f}, {circle_y:.8f}, {circle_z:.8f}, 0.00000000, 0.00000000, 1.00000000, {radius:.8f}\n"
        temp +="MODE / PROG\n"
        temp +=f"POINTDIST / PARAMS, FA({self._id})\n"
        
        point_list = self.add_support_points()


        for index, point in enumerate(point_list):
                
            if point['type'] == "single":
                
                p, v = self.calc_point_position(point['angle'])

                if index == 0:
                    temp += "PIEZOWFP / OFF\n"
                    temp += f"MEAS / CIRCLE, F(Cir_1), {len(self._points)}\n"
                
                temp += "SNSET / VA(SCAN_NOMGEO_6500)\n"
                temp += f"SNSLCT / S({self._probe._name})\n"
                temp += f"SNSET / SEARCH, {self._probe._search}\n"
                temp += f"SNSET / APPRCH, {self._probe._approach}\n"
                
                # if index == 0 and self._saftey_plane or point['MTSP']: 
                #     temp += self.get_saftey_plane()
                
                if (sp:=self.get_saftey_plane()) and index == 0 or point['MTSP']: temp += sp

                vi = v * -1
                pa = p + self._position
                temp += f"PTMEAS / CART, {pa[0]:.8f}, {pa[1]:.8f}, {pa[2]:.8f}, {vi[0]:.8f}, {vi[1]:.8f}, {vi[2]:.8f}\n"

       
            elif point['type'] == "support":
                p, v = self.calc_point_position(point['angle'])
                approach = self._probe._approach + (self._probe._diameter / 2)
                pa = p + self._position
                temp += f"GOTO / {pa[0] + (approach * v[0]):.8f}, {pa[1] + (approach * v[1]):.8f}, {pa[2] + (approach * v[2]):.8f}\n"
            
            elif point['type'] == "scan":
                
                if index == 0:
                    temp +="SPLINESCAN3D / PARAMS, 0.10000000, 0.02000000, 5.00000000, 0.10000000, 50.00000000, 1, 0\n"
                    temp +="SCANFILTER / ON, 0.80000000, 0.00500000\n"
                    temp +="PIEZOWFP / OFF\n"
                    temp +=f"MEAS / CIRCLE, F({self._id}), {len(point['angles'])}\n"

                for index, d in enumerate(point['angles']):
                    # FIXME
                    i = np.cos(np.radians(d))
                    j = np.sin(np.radians(d))
                    x = (radius * i) + circle_x
                    y = (radius * j) + circle_y
                    z = circle_z

                    temp +="SNSET / VA(SCAN_NOMGEO_6503)\n"
                    temp +=f"SNSLCT / S({self._probe._name})\n"
                    temp +=f"SNSET / VA(SCAN_SPEED), {self._probe._scan_speed}\n"
                    temp +=f"SNSET / VA(SCAN_DEV_EXT), {self._probe._deflection}\n"
                    temp +=f"SNSET / SEARCH, {self._probe._search}\n"
                    temp +=f"SNSET / APPRCH, {self._probe._approach}\n"
                    if (sp:=self.get_saftey_plane()) and index == 0 or point['MTSP']: temp += sp

                    temp +=f"PTMEAS / CART, {x:.8f}, {y:.8f}, {z:.8f}, {i:.8f}, {j:.8f}, 0.00000000\n"
        

        temp +="ENDMES\n"

        if self._output:
            temp += self._output

        temp += "\n"

        return temp


class M_Cylinder(Element):
    
    def __init__(self) -> None:
        pass


class Output:
    _id = None
    _element = None
    _output = None
    
    def __init__(self, w: Werth | Pattern, name, element) -> None:
        if isinstance(w, Werth):
            self._id = name
        elif isinstance(w, Pattern):
            self._id = name + f"_${w._loop_var}"


        self._element = element
        self._output = ""
        w.add(self)


    def diameter(self, utol=0.0, ltol=0.0):
        # dia = dia if dia else self._element._diameter 
        temp = f"T({self._id}_D) = TOL / DIAM, {utol:.8f}, {ltol:.8f}\n"
        temp += f"OUTPUT / F({self._element._id}), T({self._id}_D)\n\n"
        self._output += temp
        return self
    
    def roundess(self, utol=0.003):
        temp = f"T({self._id}_RN) = TOL / CIRLTY, {utol:.8f}, {0.0:.8f}\n"
        temp += f"OUTPUT / F({self._element._id}), T({self._id}_RN)\n\n"
        self._output += temp
        return self

    def xValue(self, nom=0.0, utol=0.015, ltol=-0.015):
        nom = f"{nom:.8f}" if type(nom) == float else nom
        temp = f"T({self._id}_X) = TOL / DISTB, NOMINL, {nom}, {utol:.8f}, {ltol:.8f}, XAXIS\n"
        temp += f"OUTPUT / F({self._element._id}), T({self._id}_X)\n\n"
        self._output += temp
        return self

    def yValue(self, nom=0.0, utol=0.015, ltol=-0.015):
        nom = f"{nom:.8f}" if type(nom) == float else nom
        temp = f"T({self._id}_Y) = TOL / DISTB, NOMINL, {nom}, {utol:.8f}, {ltol:.8f}, YAXIS\n"
        temp += f"OUTPUT / F({self._element._id}), T({self._id}_Y)\n\n"
        self._output += temp
        return self

    def zValue(self, nom=0.0, utol=0.015, ltol=-0.015):
        nom = f"{nom:.8f}" if type(nom) == float else nom
        temp = f"T({self._id}_Z) = TOL / DISTB, NOMINL, {nom}, {utol:.8f}, {ltol:.8f}, ZAXIS\n"
        temp += f"OUTPUT / F({self._element._id}), T({self._id}_Z)\n\n"
        self._output += temp
        return self

    def point(self, pos: list[float]=None, vec: list[float]=None):
        temp = f"TEXT / OUTPUT , '{self._element._id},point,&{self._element._id}|x,&{self._element._id}|y,&{self._element._id}|z,{pos[0]},{pos[1]},{pos[2]},{vec[0]},{vec[1]},{vec[2]}'\n\n"
        self._output += temp
        return self

    def __str__(self) -> str:
        return self._output
    

class Distance_Between:
    _id = None
    _element1 = None
    _element2 = None
    _output = None
    
    def __init__(self, w: Werth | Pattern, name: str, element1, element2) -> None:
        if isinstance(w, Werth):
            self._id = name
        elif isinstance(w, Pattern):
            self._id = name + f"_${w._loop_var}"
        
        self._element1 = element1
        self._element2 = element2
        self._output = ""

        w.add(self)

    def xValue(self, nom: float, utol: float, ltol: float):
        self._output += f"T(T_$L1) = TOL / DISTB, NOMINL, {nom}, {utol}, {ltol}, XAXIS\n"
        self._output += f"OUTPUT / F(Dist1_$L1), T(T_$L1)\n\n"

    def yValue(self, nom: float, utol: float, ltol: float):
        self._output += f"T(T_$L1) = TOL / DISTB, NOMINL, {nom}, {utol}, {ltol}, YAXIS\n"
        self._output += f"OUTPUT / F(Dist1_$L1), T(T_$L1)\n\n"

    def zValue(self, nom: float, utol: float, ltol: float):
        self._output += f"T(T_$L1) = TOL / DISTB, NOMINL, {nom}, {utol}, {ltol}, ZAXIS\n"
        self._output += f"OUTPUT / F(Dist1_$L1), T(T_$L1)\n\n"


    def __str__(self) -> str:
        temp = f"F({self._id}) = FEAT / DIST, CART, 0.00000000, 0.00000000, 0.70000000, -0.00000000, 0.00000000, -1.00000000, 1.00000000\n"
        temp += f"CONST / DIST, F({self._id}), BF, FA({self._element1._id}), FA({self._element2._id})\n\n"
        temp += f"T(T_{self._id}) = TOL / DISTB, NOMINL, 0.70000000, 0.01500000, -0.015000000, ZAXIS\n"
        temp += f"OUTPUT / F(Dist1_$L1), T(T_{self._id}_$L1)\n\n"

        return temp
    

class Call:
    _programPath = None
    _filename = None

    def __init__(self, w: Werth, programPath: str) -> None:
        self._programPath = os.path.abspath(programPath)
        self._filename = os.path.basename(self._programPath).removesuffix(".dms")

        w.add(self)

    def definition(self):
        return f"INCLUDE / '{self._programPath}'\n\n"

    def __str__(self) -> str:
        return f"CALL / {self._filename}|1\n"
        

class Endpoint(Element):
    _position = None
    _saftey_plane = None
    _probe = None

    def __init__(self,w: Werth, x: float, y: float, z: float, probe: Probe = None, saftey_plane=None) -> None:
        super().__init__(w, "", saftey_plane, probe)
        self._position = np.array([x, y, z])

    def __str__(self) -> str:
        if self._saftey_plane:
            temp = f"CZSLCT / CZ({self._saftey_plane._id}), ON, FIX\n"
        temp += f"SNSLCT / S({self._probe._name})\n"
        p = self._position
        temp += f"GOTO / {p[0]:.8f}, {p[1]:.8f}, {p[2]:.8f}\n\n"
        return temp


class DMIS:
    _dmis = ""
    def __init__(self, w: Werth, dmis: str) -> None:
        self._dmis = dmis
        w.add(self)

    def __str__(self) -> str:
        return self._dmis


class Protokol_open:
    _filename = None

    def __init__(self, w: Werth, filename: str) -> None:
        self._filename = filename
        w.add(self)

    def __str__(self) -> str:
        return f"PROTOCOL / FILE, 1, '{self._filename}'\n\n"
    
       
class Protokol_close:
    def __init__(self, w: Werth) -> None:
        w.add(self)

    def __str__(self) -> str:
        return f"PROTOCOL / FILE, 0\n\n"
    

def projectToPlane(elem: list):
    
    return [elem[0], elem[1], 1.0]


def intersect(elem1: M_Line, elem2: M_Line):

    p1 = projectToPlane(elem1._position)
    v1 = projectToPlane(elem1._position + elem1._vector)

    p2 = projectToPlane(elem2._position)
    v2 = projectToPlane(elem2._position + elem2._vector)

    l1 = np.cross(p1, v1 )
    l2 = np.cross(p2, v2 )

    cp = np.cross(l1, l2)

    return[cp[0] / cp[2], cp[1] / cp[2], elem1._position[2]]


class T_Intersection:
    _id = None
    _elem1 = None
    _elem2 = None

    def __init__(self, w: Werth, name, elem1, elem2) -> None:
        self._id = name
        self._elem1 = elem1
        self._elem2 = elem2
        w.add(self)

    def __str__(self) -> str:
        point = intersect(self._elem1, self._elem2)
        temp = f"F({self._id}) = FEAT / POINT, CART, {point[0]:.8f}, {point[1]:.8f}, {point[2]:.8f}, 0.00000000, 0.00000000, 0.00000000\n"
        temp += "WKPLAN / NONE\n"
        temp += f"CONST / POINT, F({self._id}), INTOF, FA({self._elem1._id}), FA({self._elem2._id})\n"
        return temp
    

class T_Symmetry:
    _id=None
    _elem1=None
    _elem2=None
    _position=None
    _vector=None

    def __init__(self, w: Werth, name, elem1: M_Line, elem2: M_Line) -> None:
        self._id=name
        self._elem1 = elem1
        self._elem2 = elem2
        self._position = (self._elem1._position + self._elem2._position) / 2
        self._vector = (self._elem1._vector + self._elem2._vector) / 2

        w.add(self)

    def __str__(self) -> str:
        pos = self._position
        vec = self._vector

        temp = f"F({self._id}) = FEAT / LINE, UNBND, CART, {pos[0]:.8f}, {pos[1]:.8f}, {pos[2]:.8f}, {vec[0]:.8f}, {vec[1]:.8f}, {vec[2]:.8f}, 0.00000000, 0.00000000, 1.00000000\n"
        temp += "WKPLAN / NONE\n"
        temp += f"CONST / LINE, F({self._id}), MIDLI, FA({self._elem1._id}), FA({self._elem2._id})\n\n"
        return temp
    

class T_Line:
    _id = None
    _position = None
    _vector = None
    _points = None
    _lines = None

    def __init__(self, w: Werth | Pattern, name: str, x: float, y: float, z: float, i: float, j: float, k: float) -> None:
        if isinstance(w, Werth):
            self._id = name
        elif isinstance(w, Pattern):
            self._id = name + f"_${w._loop_var}"


        self._position = np.array([x, y, z])
        self._vector = np.array([i, j, k])

        w.add(self)

    def points(self, points = None):
        self._points = points

    def symmetry(self, lines = None):
        self._lines = lines


    def __str__(self) -> str:

        x, y, z = self._position
        i, j, k = self._vector

        temp = f"FA({self._id}) = FEAT / LINE, UNBND, CART, {x},{y},{z},{i},{j},{k}, 0.00000000, 0.00000000,1.00000000\n"
        
        if self._points:
            points = ','.join([f"FA({item._id}) " for item in self._points])
            temp += "WKPLAN / NONE\n"
            temp += f"CONST / LINE, F({self._id}), BF, {points}\n"

        if self._lines:
            lines = ','.join([f"FA({item._id}) " for item in self._lines])
            temp += "WKPLAN / NONE\n"
            temp += f"CONST / MIDLI, F({self._id}), BF, {lines}\n"


        temp += "\n"
        return temp

